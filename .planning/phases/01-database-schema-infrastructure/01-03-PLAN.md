---
phase: 01-database-schema-infrastructure
plan: 03
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - supabase/migrations/_rls_new_tables.sql
autonomous: true
requirements:
  - DB-05

must_haves:
  truths:
    - "User A cannot read or write User B's meals"
    - "User A cannot read or write User B's meal items"
    - "User A cannot read or write User B's body weight entries"
    - "Unmatched ingredients are insert-only for authenticated users and readable by service role only"
    - "All new tables have RLS enabled with no permissive default"
  artifacts:
    - path: "supabase/migrations/*_rls_new_tables.sql"
      provides: "RLS policies for meals, meal_items, body_weight_log, unmatched_ingredients"
      contains: "ENABLE ROW LEVEL SECURITY"
  key_links:
    - from: "meals RLS policy"
      to: "auth.uid() = user_id"
      via: "USING clause on SELECT/UPDATE/DELETE, WITH CHECK on INSERT"
      pattern: "auth\\.uid\\(\\).*=.*user_id"
    - from: "meal_items RLS policy"
      to: "meals.user_id via JOIN"
      via: "meal_items has no user_id column — RLS must join through meals table"
      pattern: "EXISTS.*SELECT.*FROM.*meals.*WHERE.*meals\\.id.*=.*meal_items\\.meal_id"
    - from: "body_weight_log RLS policy"
      to: "auth.uid() = user_id"
      via: "direct user_id check"
      pattern: "auth\\.uid\\(\\).*=.*user_id"
---

<objective>
Create RLS policies for all new tables so users can only access their own data.

Purpose: Security boundary enforcement. Without RLS, any authenticated user could read/modify any other user's meals, weight entries, and nutrition data. This is a Supabase requirement for any user-facing table.

Output: One raw SQL migration file (Domain B) with RLS policies for meals, meal_items, body_weight_log, and unmatched_ingredients.
</objective>

<execution_context>
@/Users/khoivo/.copilot/get-shit-done/workflows/execute-plan.md
@/Users/khoivo/.copilot/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-database-schema-infrastructure/01-CONTEXT.md

@supabase/migrations/20260224100032_rls_and_triggers.sql
@supabase/migrations/20260226172614_food_composition_rls.sql

<!-- Plan 01-01 SUMMARY will exist by execution time (Wave 2 depends on Wave 1) -->
@.planning/phases/01-database-schema-infrastructure/01-01-SUMMARY.md

<interfaces>
<!-- Table structures from Plan 01-01 that RLS policies reference -->

meals table:
- user_id uuid NOT NULL REFERENCES auth.users(id) — direct ownership column
- All CRUD operations need user_id-based RLS

meal_items table:
- meal_id uuid NOT NULL REFERENCES meals(id) — NO direct user_id column
- RLS must JOIN through meals to verify ownership
- This is the critical pattern — meal_items inherit access from their parent meal

body_weight_log table:
- user_id uuid NOT NULL REFERENCES auth.users(id) — direct ownership column
- All CRUD operations need user_id-based RLS

unmatched_ingredients table:
- meal_id uuid REFERENCES meals(id) — indirect ownership via meal
- This is a logging/analytics table — users INSERT via the AI pipeline, only service role reads

<!-- Existing RLS patterns to follow -->
From 20260224100032_rls_and_triggers.sql:
```sql
ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own profile"
  ON public.user_profiles FOR SELECT
  USING (auth.uid() = user_id);
CREATE POLICY "Users can update own profile"
  ON public.user_profiles FOR UPDATE
  USING (auth.uid() = user_id);
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RLS migration for all new tables</name>
  <files>supabase/migrations/_rls_new_tables.sql</files>
  <action>
Create a new raw SQL migration file in `supabase/migrations/` with a timestamp prefix (use current timestamp, must be AFTER the Plan 01-01 migration timestamp). Follow Domain B conventions (header comment block matching `20260224100032_rls_and_triggers.sql` style).

**Also create an `updated_at` trigger function** (reusable) and apply it to the `meals` table, since meals has an `updated_at` column that should auto-update on modification.

**Section 1: updated_at trigger (reusable)**
```sql
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_meals_updated
  BEFORE UPDATE ON public.meals
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_updated_at();
```

Note: `user_profiles` also has `updated_at` but its trigger may not exist yet. Check and apply there too if missing:
```sql
DROP TRIGGER IF EXISTS on_user_profiles_updated ON public.user_profiles;
CREATE TRIGGER on_user_profiles_updated
  BEFORE UPDATE ON public.user_profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_updated_at();
```

**Section 2: meals RLS**
```sql
ALTER TABLE public.meals ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own meals"
  ON public.meals FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own meals"
  ON public.meals FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own meals"
  ON public.meals FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own meals"
  ON public.meals FOR DELETE
  USING (auth.uid() = user_id);
```

**Section 3: meal_items RLS**
meal_items has NO direct user_id — ownership is inherited through the parent meal. Use an EXISTS subquery to check ownership via the meals table:

```sql
ALTER TABLE public.meal_items ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own meal items"
  ON public.meal_items FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.meals
      WHERE meals.id = meal_items.meal_id
        AND meals.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can insert own meal items"
  ON public.meal_items FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.meals
      WHERE meals.id = meal_items.meal_id
        AND meals.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can update own meal items"
  ON public.meal_items FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM public.meals
      WHERE meals.id = meal_items.meal_id
        AND meals.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can delete own meal items"
  ON public.meal_items FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM public.meals
      WHERE meals.id = meal_items.meal_id
        AND meals.user_id = auth.uid()
    )
  );
```

**Section 4: body_weight_log RLS**
```sql
ALTER TABLE public.body_weight_log ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own weight entries"
  ON public.body_weight_log FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own weight entries"
  ON public.body_weight_log FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own weight entries"
  ON public.body_weight_log FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own weight entries"
  ON public.body_weight_log FOR DELETE
  USING (auth.uid() = user_id);
```

**Section 5: unmatched_ingredients RLS**
This is a logging table — authenticated users can INSERT (via AI pipeline), but only service_role can SELECT (for admin/analytics). No UPDATE or DELETE for regular users.

```sql
ALTER TABLE public.unmatched_ingredients ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can insert unmatched ingredients"
  ON public.unmatched_ingredients FOR INSERT
  WITH CHECK (auth.role() = 'authenticated');
```
No SELECT/UPDATE/DELETE policies for regular users — only service_role (which bypasses RLS) can read this data.
  </action>
  <verify>
    <automated>cd /Users/khoivo/Documents/nham && cat supabase/migrations/*rls_new* | grep -c "CREATE POLICY\|ENABLE ROW LEVEL"</automated>
  </verify>
  <done>Migration file exists with: RLS enabled on all 4 new tables. meals and body_weight_log have full CRUD policies using `auth.uid() = user_id`. meal_items has full CRUD policies using EXISTS subquery through meals. unmatched_ingredients has INSERT-only policy for authenticated users. updated_at trigger applied to meals table.</done>
</task>

</tasks>

<verification>
1. Migration file exists in `supabase/migrations/` with `rls` in the filename
2. All 4 tables have `ENABLE ROW LEVEL SECURITY`
3. meals: 4 policies (SELECT, INSERT, UPDATE, DELETE) with `auth.uid() = user_id`
4. meal_items: 4 policies using EXISTS subquery through meals.user_id
5. body_weight_log: 4 policies with `auth.uid() = user_id`
6. unmatched_ingredients: 1 INSERT policy for authenticated users, no SELECT for regular users
7. updated_at trigger on meals table
8. File follows Domain B conventions (header comment, raw SQL, no Drizzle)
9. Migration timestamp is AFTER the Plan 01-01 migration timestamp
</verification>

<success_criteria>
- RLS enabled on meals, meal_items, body_weight_log, unmatched_ingredients
- User A cannot read/write User B's data across all tables
- meal_items access correctly mediated through parent meal ownership
- unmatched_ingredients is insert-only for regular users
- updated_at trigger auto-fires on meals UPDATE
- Migration follows existing Domain B conventions
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-schema-infrastructure/01-03-SUMMARY.md`
</output>
