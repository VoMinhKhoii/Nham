---
phase: 01-database-schema-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/_pgvector_embeddings.sql
autonomous: true
requirements:
  - DB-01

must_haves:
  truths:
    - "pgvector extension is enabled in the database"
    - "Each food composition row has a vector embedding derived from its Vietnamese and English names"
    - "A semantic similarity query returns correct matches for Vietnamese synonym inputs (e.g., 'ba rọi' matches 'Thịt lợn ba chỉ')"
    - "An HNSW index accelerates vector similarity searches"
    - "A match_ingredients SQL function returns top-N candidates by cosine similarity"
  artifacts:
    - path: "supabase/migrations/*_pgvector_embeddings.sql"
      provides: "pgvector extension, embedding column, HNSW index, match_ingredients function, embedding generation trigger"
      contains: "CREATE EXTENSION vector"
    - path: "supabase/migrations/*_pgvector_embeddings.sql"
      provides: "SQL to generate embeddings for existing food composition rows"
      contains: "supabase_extras.moondream_embed"
  key_links:
    - from: "vietnamese_food_composition.embedding"
      to: "match_ingredients function"
      via: "cosine similarity operator <=>"
      pattern: "embedding.*<=>"
    - from: "match_ingredients(query_embedding)"
      to: "vietnamese_food_composition"
      via: "HNSW index scan"
      pattern: "ORDER BY.*<=>"
---

<objective>
Enable pgvector, add embedding column to vietnamese_food_composition, create HNSW index, build the match_ingredients search function, and generate embeddings for all existing rows.

Purpose: Semantic ingredient matching is the core of the AI pipeline — it handles Vietnamese synonyms (thịt ba chỉ/ba rọi/thịt mỡ), misspellings, and LLM extraction errors via vector similarity instead of exact text matching. Without this, Phase 3 (AI Pipeline) cannot ground its outputs.

Output: One raw SQL migration file (Domain B — not Drizzle-managed) that sets up the complete pgvector infrastructure.
</objective>

<execution_context>
@/Users/khoivo/.copilot/get-shit-done/workflows/execute-plan.md
@/Users/khoivo/.copilot/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-database-schema-infrastructure/01-CONTEXT.md

@supabase/migrations/20260226172553_add_food_composition.sql
@supabase/migrations/20260226172614_food_composition_rls.sql
@supabase/seed.sql

<interfaces>
<!-- Existing vietnamese_food_composition table columns relevant to embeddings -->
From supabase/migrations/20260226172553_add_food_composition.sql:
```sql
CREATE TABLE "vietnamese_food_composition" (
  "id" text PRIMARY KEY NOT NULL,
  "name_primary" text NOT NULL,    -- Vietnamese primary name
  "name_alt" text[],               -- Vietnamese alternate names (often empty)
  "name_en" text NOT NULL,         -- English name
  "type_vn" text NOT NULL,         -- Vietnamese food category
  "type_en" text NOT NULL,         -- English food category
  "source" text DEFAULT 'FAO_VN_2007' NOT NULL,
  "state" text NOT NULL,           -- 'raw' or 'cooked'
  ...
);
```

Key data characteristics (from CONTEXT.md):
- 526 rows in the food composition table
- name_alt arrays are mostly empty — embeddings must rely primarily on name_primary + name_en
- Combined text for embedding: concatenate name_primary + name_alt (joined) + name_en
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pgvector infrastructure migration</name>
  <files>supabase/migrations/_pgvector_embeddings.sql</files>
  <action>
Create a new raw SQL migration file in `supabase/migrations/` with a timestamp prefix following the existing pattern (e.g., `YYYYMMDDHHMMSS_pgvector_embeddings.sql`). Use the current timestamp.

This is a **Domain B** migration (raw SQL, not Drizzle-managed). Add the standard Domain B header comment block matching the style in `20260224100032_rls_and_triggers.sql`.

The migration must contain these sections in order:

**1. Enable pgvector extension:**
```sql
CREATE EXTENSION IF NOT EXISTS vector WITH SCHEMA extensions;
```

**2. Add embedding column to vietnamese_food_composition:**
```sql
ALTER TABLE public.vietnamese_food_composition
  ADD COLUMN IF NOT EXISTS embedding vector(384);
```
Use 384 dimensions — this matches Supabase's built-in `gte-small` model (via `ai.gte_small` or the `supabase_extras.moondream_embed` equivalent). The executor should verify which embedding function is available on the linked Supabase project. Common options:
- `ai.embed('gte-small', text)` — if the `ai` schema is available
- `extensions.embedding('gte-small', text)` — Supabase vault-based
- Fall back to creating an Edge Function if neither is available in-database

**3. Create helper function to build embedding input text:**
```sql
CREATE OR REPLACE FUNCTION public.build_food_embedding_text(
  p_name_primary text,
  p_name_alt text[],
  p_name_en text
) RETURNS text AS $$
BEGIN
  RETURN p_name_primary
    || COALESCE(' ' || array_to_string(p_name_alt, ' '), '')
    || ' ' || p_name_en;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

**4. Create match_ingredients function for semantic search:**
```sql
CREATE OR REPLACE FUNCTION public.match_ingredients(
  query_embedding vector(384),
  match_count int DEFAULT 3,
  match_threshold float DEFAULT 0.5
) RETURNS TABLE (
  id text,
  name_primary text,
  name_alt text[],
  name_en text,
  state text,
  similarity float
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    vfc.id,
    vfc.name_primary,
    vfc.name_alt,
    vfc.name_en,
    vfc.state,
    1 - (vfc.embedding <=> query_embedding) AS similarity
  FROM public.vietnamese_food_composition vfc
  WHERE vfc.embedding IS NOT NULL
  ORDER BY vfc.embedding <=> query_embedding
  LIMIT match_count;
END;
$$ LANGUAGE plpgsql STABLE;
```
Note: The threshold parameter is available for future filtering but the initial implementation returns top-N by distance. The AI pipeline (Phase 3) will use the confidence scores to decide match quality.

**5. Create HNSW index for fast similarity search:**
```sql
CREATE INDEX IF NOT EXISTS idx_food_composition_embedding
  ON public.vietnamese_food_composition
  USING hnsw (embedding vector_cosine_ops)
  WITH (m = 16, ef_construction = 64);
```
HNSW chosen over IVFFlat because: small dataset (526 rows), HNSW provides better recall at this scale, no need for periodic re-training. Parameters m=16 and ef_construction=64 are appropriate defaults for a table this size.

**6. Generate embeddings for all existing rows:**
Write a DO block that iterates over all rows and generates embeddings. The exact approach depends on what's available:

Option A (preferred — in-database AI):
```sql
-- Generate embeddings using Supabase AI
UPDATE public.vietnamese_food_composition
SET embedding = ai.embed(
  'gte-small',
  build_food_embedding_text(name_primary, name_alt, name_en)
)::vector(384)
WHERE embedding IS NULL;
```

Option B (if ai schema not available — use Edge Function):
If `ai.embed` is not available, create a comment noting that embeddings must be generated via an Edge Function or external script, and leave the UPDATE as a placeholder. Document this clearly so the executor knows to check and adapt.

The executor MUST verify which embedding approach works on the actual Supabase instance before finalizing. Test with:
```sql
SELECT ai.embed('gte-small', 'test')::vector(384);
```
If this errors, fall back to Option B.
  </action>
  <verify>
    <automated>cd /Users/khoivo/Documents/nham && cat supabase/migrations/*pgvector* | grep -c "CREATE\|ALTER\|FUNCTION\|INDEX"</automated>
  </verify>
  <done>Migration file exists with: pgvector extension enabled, embedding column added to vietnamese_food_composition, build_food_embedding_text helper function, match_ingredients search function returning top-N by cosine similarity, HNSW index on embedding column, and embedding generation for all existing rows (or documented fallback if in-database AI unavailable).</done>
</task>

</tasks>

<verification>
1. Migration file exists in `supabase/migrations/` with `pgvector` in the filename
2. File contains `CREATE EXTENSION IF NOT EXISTS vector`
3. File contains `ALTER TABLE ... ADD COLUMN ... embedding vector(384)`
4. File contains `CREATE OR REPLACE FUNCTION public.match_ingredients` with cosine similarity
5. File contains `CREATE INDEX ... USING hnsw`
6. File contains embedding generation logic (UPDATE or documented fallback)
7. File follows Domain B conventions (header comment, raw SQL, no Drizzle)
</verification>

<success_criteria>
- pgvector extension enabled
- embedding column (vector(384)) added to vietnamese_food_composition
- match_ingredients function created returning top-N candidates by cosine similarity
- HNSW index created for fast vector search
- Embedding generation approach implemented or clearly documented
- Migration follows existing Domain B conventions
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-schema-infrastructure/01-02-SUMMARY.md`
</output>
