---
phase: 01.1-ci-cd-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [.github/workflows/ci.yml, supabase/config.toml]
autonomous: false
requirements: [CI-01, CI-02, CI-03]

must_haves:
  truths:
    - "PRs to main trigger parallel CI jobs: Biome lint, ESLint, type check, unit test, build, migration validation"
    - "Pushes to main trigger the same CI workflow"
    - "Supabase migrations apply cleanly against a local Postgres with pgvector and pg_trgm extensions"
    - "Next.js build succeeds with placeholder NEXT_PUBLIC_* env vars"
    - "In-progress CI runs are cancelled when new commits push to the same branch"
    - "Only search-pipeline integration tests are excluded (need live embeddings); all other tests run"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "CI pipeline with 6 parallel jobs"
    - path: "supabase/config.toml"
      provides: "Local Supabase configuration for migration validation in CI and local dev"
  key_links:
    - from: ".github/workflows/ci.yml (migrations job)"
      to: "supabase/migrations/"
      via: "supabase start + supabase db reset applies all migrations"
      pattern: "supabase db reset"
    - from: ".github/workflows/ci.yml (test job)"
      to: "vitest"
      via: "--exclude flag filtering out search-pipeline DB tests"
      pattern: "exclude.*lib/db/__tests__"
    - from: "supabase/config.toml"
      to: ".github/workflows/ci.yml (migrations job)"
      via: "supabase start reads config.toml for local instance"
      pattern: "supabase start"
---

<objective>
Create a GitHub Actions CI workflow with 6 parallel quality check jobs: linting (Biome + ESLint), type checking, unit tests, production build, and Supabase migration validation.

Purpose: Establish an automated quality gate so broken code — including invalid SQL migrations — cannot merge. Currently all checks are manual.
Output: `.github/workflows/ci.yml` with 6 parallel jobs, `supabase/config.toml` for local Supabase.
</objective>

<execution_context>
@/Users/khoivo/.copilot/get-shit-done/workflows/execute-plan.md
@/Users/khoivo/.copilot/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01.1-ci-cd-pipeline/01.1-RESEARCH.md
@AGENTS.md
@package.json
@biome.json
@vitest.config.ts
@supabase/migrations/ (10 migration files — Drizzle DDL + manual Domain B SQL for pgvector, pg_trgm, RLS)
@supabase/seed.sql (526 food composition records)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CI workflow and Supabase config</name>
  <files>.github/workflows/ci.yml, supabase/config.toml</files>
  <action>
**Step A: Create `supabase/config.toml`**

Generate a minimal Supabase config for local development and CI. Run `supabase init` in a temp directory to get the default config, then copy it to the project. OR create a minimal config manually with these key settings:
- `[project]` section with empty `id` (filled per-environment)
- `[db]` section with port 54322, major_version = 15
- `[api]` section enabled on port 54321
- `[studio]` section disabled (not needed for CI or headless dev)

The simplest approach: run `supabase init --workdir /tmp/sb-init && cp /tmp/sb-init/supabase/config.toml supabase/config.toml` then clean up. This generates a proper default config. Alternatively, use a known-good minimal config.

**Step B: Create `.github/workflows/ci.yml`**

**Triggers:** `push` to `main` and `pull_request` targeting `main`.

**Concurrency:** Group by `${{ github.workflow }}-${{ github.ref }}`, cancel in-progress runs.

**6 parallel jobs (all on `ubuntu-latest`):**

1. **lint** (name: "Lint (Biome)")
   - `actions/checkout@v4`
   - `biomejs/setup-biome@v2` (auto-detects Biome 2.4.2 from biome.json schema)
   - Run: `biome ci .` (NOT `biome check` — `ci` subcommand is CI-specific, exits non-zero on any issue)

2. **eslint** (name: "Lint (ESLint)")
   - `actions/checkout@v4`
   - `oven-sh/setup-bun@v2` (built-in dependency caching)
   - `bun install --frozen-lockfile`
   - Run: `bun lint`

3. **typecheck** (name: "Type Check")
   - `actions/checkout@v4`
   - `oven-sh/setup-bun@v2`
   - `bun install --frozen-lockfile`
   - Run: `bunx tsc --noEmit`

4. **test** (name: "Unit Test")
   - `actions/checkout@v4`
   - `oven-sh/setup-bun@v2`
   - `bun install --frozen-lockfile`
   - Run: `bun vitest run --exclude '**/lib/db/__tests__/**'`
   - WHY exclude: `lib/db/__tests__/search-pipeline.test.ts` requires `DATABASE_URL` pointing to live Supabase with populated embeddings. Migration validation is handled by the dedicated migrations job below. Other tests (utils, hooks, route, meal-logic) run normally.

5. **build** (name: "Build")
   - `actions/checkout@v4`
   - `oven-sh/setup-bun@v2`
   - `bun install --frozen-lockfile`
   - Job-level `env` block with placeholder values:
     - `NEXT_PUBLIC_SUPABASE_URL: "https://placeholder.supabase.co"`
     - `NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY: "placeholder"`
   - Run: `bun run build`
   - WHY placeholders: Next.js inlines `NEXT_PUBLIC_*` at build time. Real builds use Vercel's env vars.

6. **migrations** (name: "Validate Migrations")
   - `actions/checkout@v4`
   - `uses: supabase/setup-cli@v1` with `version: latest`
   - Start local Supabase (Postgres only, skip unnecessary services):
     ```
     supabase start -x realtime,storage-api,imgproxy,inbucket,postgrest,gotrue,studio,edge-runtime,vector
     ```
   - Apply all migrations + seed: `supabase db reset`
     This validates: SQL syntax, migration ordering, extension availability (pgvector, pg_trgm), FK constraints, function/trigger creation, seed data integrity.
   - Run `supabase db lint` to check for schema issues (missing indexes, unsafe patterns).
   - Stop with `if: always()`: `supabase stop --no-backup`
   - WHY local Supabase: Migrations use pgvector, pg_trgm, and custom functions. Simple SQL parsing cannot validate these — a real Postgres with extensions is needed.

No manual `actions/cache` needed — `oven-sh/setup-bun@v2` handles Bun's global cache automatically.

NOTE on preview deployments: Vercel already creates preview deployments for every PR automatically. No additional CI job needed for previews.
  </action>
  <verify>
    <automated>cat .github/workflows/ci.yml && python3 -c "import yaml; y=yaml.safe_load(open('.github/workflows/ci.yml')); jobs=list(y.get('jobs',{}).keys()); print(f'Jobs: {jobs}'); assert len(jobs) == 6, f'Expected 6 jobs, got {len(jobs)}'; assert 'migrations' in jobs, 'Missing migrations job'" && test -f supabase/config.toml && echo "config.toml exists"</automated>
  </verify>
  <done>`.github/workflows/ci.yml` exists with 6 parallel jobs (lint, eslint, typecheck, test, build, migrations). `supabase/config.toml` exists for local Supabase.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify CI pipeline on GitHub + configure branch protection</name>
  <files>.github/workflows/ci.yml</files>
  <action>
Commit and push the workflow + config files to trigger CI. Verify all 6 jobs pass on GitHub Actions.

What was built: GitHub Actions CI workflow with 6 parallel quality check jobs:
- Lint (Biome) — formatting and general linting
- Lint (ESLint) — Next.js-specific rules
- Type Check — TypeScript strict mode
- Unit Test — Vitest (excluding search-pipeline DB tests)
- Build — Next.js production build
- Validate Migrations — All Supabase migrations apply cleanly with pgvector/pg_trgm

How to verify:
1. The workflow + config files have been committed and pushed
2. Go to https://github.com/VoMinhKhoii/Nham/actions to verify the CI workflow triggered
3. Confirm all 6 jobs appear and run in parallel
4. Wait for all jobs to pass (green checkmarks)
5. Check the "Validate Migrations" job logs specifically — confirm it starts local Supabase, applies all 10 migrations, seeds 526 records, and runs db lint
6. If any job fails, review the logs and report the failure

Branch protection (recommended):
7. Go to repo Settings → Branches → Add branch ruleset for `main`
8. Enable "Require status checks to pass before merging"
9. Add required checks: Lint (Biome), Lint (ESLint), Type Check, Unit Test, Build, Validate Migrations
  </action>
  <verify>All 6 CI jobs show green checkmarks on https://github.com/VoMinhKhoii/Nham/actions</verify>
  <done>CI pipeline runs successfully on GitHub Actions with all 6 jobs passing. Branch protection configured to require CI checks before merging.</done>
</task>

</tasks>

<verification>
- [ ] `.github/workflows/ci.yml` exists with valid YAML syntax
- [ ] `supabase/config.toml` exists for local Supabase instance
- [ ] Workflow triggers on push to main and PRs targeting main
- [ ] 6 parallel jobs: Biome lint, ESLint, TypeScript check, unit tests, build, migration validation
- [ ] Migration validation job starts local Supabase, applies all migrations, runs db lint
- [ ] Only search-pipeline tests excluded (need live embeddings); all other tests run
- [ ] Build job has placeholder `NEXT_PUBLIC_*` env vars
- [ ] Concurrency cancels in-progress runs on same branch
- [ ] All 6 CI jobs pass on GitHub Actions
</verification>

<success_criteria>
All 6 CI jobs pass green on a push or PR to main. Migrations are validated against a real Postgres with pgvector/pg_trgm. Branch protection enforces all checks before merge. The workflow is committed to the repository.
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-ci-cd-pipeline/01.1-01-SUMMARY.md`
</output>
